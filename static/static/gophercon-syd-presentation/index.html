<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>Sloc Cloc and Code - Can a crusty Go program outperform a well written Rust Project?</title>
		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">
		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Sloc Cloc and Code</h1>
					<h3>Can a crusty Go program outperform a well written Rust Project?</h3>
				</section>
				<section>
					<table>
						<tr>
							<td>
								<img src="./img/ben.jpg" >
							</td>
							<td>
								Ben Boyter<br>
								Offically Tech Lead<br>
								Really a Code Monkey for <a href="https://www.kablamo.com.au/">Kablamo</a>.
								<pre><code style="font-size: 16px;">func Produce(c Coffee, b Beer) (Code, Cloud, []error)</code></pre>
								Can a crusty Go program outperform a well written Rust Project?<br>
							</td>
						</tr>
					</table>
				</section>

				<section>
					<img src="./img/overcorrecting.jpg" height="650px" />
				</section>

				<section>
					<h2>Code Iceberg</h2>
					<img src="./img/code-iceberg.jpg" />
					<small>Image by Â© Ralph A. Clevenger/CORBIS</small>
				</section>

				<section>
					<h2>How to spot code icebergs?</h2>
					<p>
					SLOC/CLOC counters<br>
					<a href="https://github.com/AlDanial/cloc">cloc</a> (the OG) counts blank lines, comment lines, and physical lines of source code in many programming languages<br>
					VERY full featured.<br>
					probably not an example of a fast program.
					</p>
				</section>

				<section>
					<h2>How to spot code icebergs? Continued...</h2>
					<p>
					Cyclomatic Complexity
					<img src="./img/code-metrics.jpg" />
					</p>
				</section>

				<section>
					<h2>BTW I am not original</h2>
					<p>
					<a href="https://github.com/XAMPPRocky/tokei">Tokei</a>, <a href="https://github.com/cgag/loc">Loc</a>, <a href="https://github.com/hhatto/gocloc">Gocloc</a>, <a href="https://github.com/vmchale/polyglot">Polyglot</a>, <a href="https://gitlab.com/esr/loccount">loccount</a>
					<br><br>
					BUT none do code complexity and author of tokei explicitly refused to add
					</p>
				</section>

				<section>
					<h2>Goals!</h2>
					Learn Go (and Go-Routines)<br>
					Be as fast as possible (and TRY to beat Rust).<br>
					Be as accurate as possible!<br>
					Be a library!<br>
					Guess complexity!<br>
				</section>


				<section>
					<h2>Design</h2>

Processes seperated by channels<br>
<img src="./img/design1.jpg" />

				</section>




				<section>
					<h2>Design</h2>

					3 ways to count code.

					<ol>
						<li>Use regex (cloc)</li>
						<li>Use AST (Visual Studio)</li>
						<li>State machine (tokei, loc, scc, polyglot)</li>
					</ol>

				</section>


				<section>
					<h2>Mechanical Sympathy</h2>
					<blockquote>"You don't have to be an engineer to be be a racing driver, but you do have to have Mechanical Sympathy."</blockquote>
					<img src="./img/jackie-stewart.jpg" height="300px" />
				</section>

				<section>
					<h2>How to Go fast in modern world</h2>
					Do less.<br>
					On many cores.<br>
					Make it easy to do the next thing.
				</section>

				<section>
					<h2>File Walking</h2>
					Go build in file walk is slow!

					https://boyter.org/2018/03/quick-comparison-go-file-walk-implementations/

					https://github.com/boyter/scc/blob/master/examples/performance_tests/create_folders_with_files.py

					# GRAPH HERE SHOWING
<pre>
Case 0 Create a directory thats quite deep and put a 10000 files at the end
Case 1 Create a directory thats quite deep and put 100 files in each folder
Case 2 Create a directory that has a single level and put 10000 files in it
Case 3 Create a directory that has a two levels with 10000 directories in the second with a single file in each
Case 4 Create a directory that with 10 subdirectories and 1000 files in each
Case 5 Create a directory that with 20 subdirectories and 500 files in each
Case 6 Create a directory that with 5 subdirectories and 2000 files in each
Case 7 Create a directory that with 100 subdirectories and 100 files in each
</pre>


				</section>

				<section>
					<h2>File Walking Continued</h2>
					What about .gitignore files?
				</section>


				<section>
					<h2>Fair Benchmarks</h2>
					No such thing.

					https://github.com/boyter/scc/blob/master/examples/performance_tests/create_performance_test.py

					Tried to create one as fair as possible
				</section>

				<section>
					<h2>Flame Graph</h2>
					<img src="./img/flame-graph.jpg" />
				</section>


				<section>
					<h2>Byte Comparison</h2>

					Which is fastest?

<pre><code style="font-size: 16px;">equal := reflect.DeepEqual(one, two)</code></pre>
<pre><code style="font-size: 16px;">equal := bytes.Equal(one, two)</code></pre>
<pre><code style="font-size: 16px;">equal := true
for j := 0; j < len(one); j++ {
	if one[j] != two[j] {
		equal = false
		break
	}
}
</code></pre>

				</section>

			</div>
		</div>
		<script src="js/reveal.js"></script>
		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>


<!--
http://webgraphviz.com/

digraph G {
  "for (byte in file_bytes)" -> "switch (state)"
  "switch (state)" -> "process (byte)"
  "process (byte)" -> "update (state)"
  "update (state)" -> "for (byte in file_bytes)"
}

digraph G {
  "for (byte in file_bytes)" -> "switch (state)"
  "switch (state)" -> "process (byte)"
  "process (byte)" -> "for (byte till newline || change state)"
  "for (byte till newline || change state)" -> "process (byte)"
  "for (byte till newline || change state)" -> "update (state)"
  "update (state)" -> "for (byte in file_bytes)"
}
-->