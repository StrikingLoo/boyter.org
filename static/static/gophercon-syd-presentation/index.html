<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>Sloc Cloc and Code - Can a crusty Go program outperform a well written Rust Project?</title>
		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">
		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Sloc Cloc and Code</h1>
					<h3>Can a crusty Go program outperform a well written Rust Project?</h3>
				</section>
				<section>
					<table>
						<tr>
							<td>
								<img src="./img/ben.jpg" >
							</td>
							<td>
								Ben Boyter<br>
								Offically Tech Lead<br>
								Really a Code Monkey for <a href="https://www.kablamo.com.au/">Kablamo</a>.
								<pre><code style="font-size: 16px;">func Produce(c Coffee, b Beer) (Code, Cloud, []error)</code></pre>
								Can a crusty Go program outperform a well written Rust Project?<br>
							</td>
						</tr>
					</table>
				</section>

				<section>
					<img src="./img/overcorrecting.jpg" height="650px" />
				</section>

				<section>
					<h2>Code Iceberg</h2>
					<img src="./img/code-iceberg.jpg" />
					<small>Image by © Ralph A. Clevenger/CORBIS</small>
				</section>

				<section>
					<h2>How to spot code icebergs?</h2>
					<p>
					SLOC/CLOC counters<br>
					<a href="https://github.com/AlDanial/cloc">cloc</a> (the OG) counts blank lines, comment lines, and physical lines of source code in many programming languages<br>
					VERY full featured.<br>
					All other tools descend from it
					</p>
				</section>

				<section>
					<h2>How to spot code icebergs? Continued...</h2>
					<p>
					Cyclomatic Complexity
					<img src="./img/code-metrics.jpg" />
					</p>
				</section>

				<section>
					<h2>Are you thinking what I am!?</h2>
					<p>
					We totally need another code counter!<br><br>
					But lets see if anyone has considered this...<br>
					<a href="https://github.com/XAMPPRocky/tokei">tokei</a>, <a href="https://github.com/cgag/loc">loc</a>, <a href="https://github.com/vmchale/polyglot">polyglot</a>, <a href="https://gitlab.com/esr/loccount">loccount</a> and <a href="https://github.com/hhatto/gocloc">gocloc</a>
					<br><br>
					SPIN! Calculate some value for code complexity.
					</p>
				</section>

				<section>
					<h2>Goals</h2>
					Learn Go.<br>
					Be as fast as possible (and TRY to beat tokei and loc).<br>
					Be <u>readable</u> Go<br>
					Push CPU to limits (unlikely) OR to my limits (likely)<br>
					Be as accurate as possible<br>
					Be a library<br>
					Guess complexity<br>
				</section>


				<section>
					<h2>Design</h2>
Processes separated by channels<br>
Channel buffers size = CPU cores for back-pressure.<br>
Tried intermediate channel buffers... no difference<br>
<img src="./img/design1.jpg" />
				</section>

				<section>
					<h2>1. File Walking</h2>
					Go's <a href="https://boyter.org/2018/03/quick-comparison-go-file-walk-implementations/">built in file walk is slow</a>! (comparatively)<br>
					Probably because its also deterministic

					

					https://github.com/boyter/scc/blob/master/examples/performance_tests/create_folders_with_files.py

					# GRAPH HERE SHOWING
<pre>
Case 0 Create a directory thats quite deep and put a 10000 files at the end
Case 1 Create a directory thats quite deep and put 100 files in each folder
Case 2 Create a directory that has a single level and put 10000 files in it
Case 3 Create a directory that has a two levels with 10000 directories in the second with a single file in each
Case 4 Create a directory that with 10 subdirectories and 1000 files in each
Case 5 Create a directory that with 20 subdirectories and 500 files in each
Case 6 Create a directory that with 5 subdirectories and 2000 files in each
Case 7 Create a directory that with 100 subdirectories and 100 files in each
</pre>


				</section>

				<section>
					<h2>1. File Walk Process</h2>
					What about .gitignore files?
				</section>


				<section>
					<h2>2. File Reading</h2>
					<p>
					Know your use case! 18554 bytes in my case<br>
					Memory maps or Scanner?<br>
					Burnt a lot of time here.<br>
<pre>$ time scc linux
DEBUG 2018-03-27T21:34:26Z: milliseconds to walk directory: 7593
--SNIP--
scc linux  11.02s user 19.92s system 669% cpu 7.623 total</pre>
					</p>

				</section>

				<section>
					<h2>3. File Processor</h2>
					<p>3 main ways to count code.</p>
					<ol>
						<li>Use regular expressions</li>
						<li>Use abstract syntax tree (AST)</li>
						<li>State machine</li>
					</ol>

				</section>


				<section>
					<h2>3. Mechanical Sympathy</h2>
					<blockquote>"You don't have to be an engineer to be be a racing driver, but you do have to have Mechanical Sympathy."</blockquote>
					<img src="./img/jackie-stewart.jpg" height="300px" />
				</section>

				<section>
					<h2>3. How to Go fast Multicore Edition</h2>
					<p>
					Do as little as possible.<br>
					On many cores.<br>
					Make it easy to do the next thing.<br><br>
					</p>
					<blockquote>"The key to making programs fast is to make them do practically nothing"</blockquote><br>
				</section>


				<section>
					<h2>3. Byte Comparison</h2>
					<p>Which is fastest?</p>
<pre><code style="font-size: 16px;">equal := reflect.DeepEqual(one, two)</code></pre>
<pre><code style="font-size: 16px;">equal := bytes.Equal(one, two)</code></pre>
<pre><code style="font-size: 16px;">equal := true
for j := 0; j < len(one); j++ {
	if one[j] != two[j] {
		equal = false
		break
	}
}
</code></pre>
				</section>

				<section>
					<h2>3. Byte Comparison</h2>
<pre>
BenchmarkCheckByteEqualityReflect-8                5000000 344.00 ns/op
BenchmarkCheckByteEqualityBytes-8                300000000   5.52 ns/op
BenchmarkCheckByteEqualityLoopWithAddtional-8    500000000   3.76 ns/op
BenchmarkCheckByteEqualityLoop-8                 500000000   3.41 ns/op <--
</pre>
				</section>

				<section>
					<h2>3. Loop & Check VS Change & Loop</h2>
					<table>
						<tr>
							<td><img src="./img/process1.png" /></td>
							<td><img src="./img/process2.png" /></td>
						</tr>
					</table>
				</section>

				<section>
					<h2>3. Loop & Check VS Change & Loop</h2>
<pre>
Benchmark #1: ./scc1 linux
  Time (mean ± σ):      2.343 s ±  0.097 s    [User: 27.740 s, System: 0.868 s]
  Range (min … max):    2.187 s …  2.509 s

Benchmark #1: ./scc2 linux
  Time (mean ± σ):      1.392 s ±  0.019 s    [User: 19.415 s, System: 0.825 s]
  Range (min … max):    1.367 s …  1.430 s
</pre>
				</section>

				<section>
					<h2>3. if statement Ordering</h2>
					<p>
						Serious micro-optimisation.<br>
						
					</p>
<pre>
$ hyperfine -m 50 'scc1 cpython'
Benchmark #1: scc1 cpython
  Time (mean ± σ):     522.9 ms ±   9.3 ms    [User: 1.890 s, System: 1.740 s]
  Range (min … max):   510.1 ms … 577.7 ms

$ hyperfine -m 50 'scc2 cpython'
Benchmark #1: scc2 cpython
  Time (mean ± σ):     491.0 ms ±  10.2 ms    [User: 1.628 s, System: 1.763 s]
  Range (min … max):   476.3 ms … 539.5 ms
</pre>
					<p>BUT in tight loops...</p>
				</section>

				<section>
					<h2>3 .Algorithms</h2>
					<p>
						Loop<br>
						Bit-Mask.<br>
						<a href="https://en.wikipedia.org/wiki/Trie">Trie</a>
					</p>
				</section>

				<section>
					<h2>3. Garbage Collector</h2>
					<p>Not tune-able. On/Off.</p>
					<img src="./img/throughput.jpg" />
				</section>


				<section>
					<h2>3. Lazy Loading</h2>
					<p>Support 200+ languages.</p>
					<p>More noticeable with smaller repositories</p>
<pre>
Benchmark #1: scc-2.1.0 redis
  Time (mean ± σ):      81.6 ms ±   5.0 ms    [User: 173.8 ms, System: 265.4 ms]
  Range (min … max):    75.5 ms …  97.1 ms

Benchmark #1: scc-2.0.0 redis
  Time (mean ± σ):     124.4 ms ±   2.4 ms    [User: 168.6 ms, System: 289.1 ms]
  Range (min … max):   120.0 ms … 128.4 ms
</pre>
				</section>

				<section>
					<h2>3. Anything else?</h2>
					<p>Probably little "low hanging fruit"</p>
				</section>


				<section>
					<h2>4. Summerise</h2>
					<p>Limited output (thankfully)</p>
					<p><a href="https://stackoverflow.com/questions/1760757/how-to-efficiently-concatenate-strings-in-go">Handy Benchmark</a></p>
<pre>
BenchmarkConcat-8              1000000  64850.00 ns/op
BenchmarkBuffer-8            200000000      6.76 ns/op
BenchmarkCopy-8             1000000000      3.06 ns/op
BenchmarkStringBuilder-8     200000000      7.74 ns/op
</pre>

<pre>
// When using columise   ~28726 ns/op
// When using home grown ~14293 ns/op
</pre>

				</section>

				<section>
					<h2>Fair Benchmarks</h2>
					No such thing.

					https://github.com/boyter/scc/blob/master/examples/performance_tests/create_performance_test.py

					Tried to create one as fair as possible
				</section>

				<section>
					<h2>Flame Graph</h2>
					<img src="./img/flame-graph.jpg" />
				</section>


				<section>
					<h2>4. Summeriser</h2>
					<p></p>
				</section>

				

			</div>
		</div>
		<script src="js/reveal.js"></script>
		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>


<!--
http://webgraphviz.com/

digraph G {
  "for (byte in file_bytes)" -> "switch (state)"
  "switch (state)" -> "process (byte)"
  "process (byte)" -> "update (state)"
  "update (state)" -> "for (byte in file_bytes)"
}

digraph G {
  "for (byte in file_bytes)" -> "switch (state)"
  "switch (state)" -> "process (byte)"
  "process (byte)" -> "for (byte till newline || change state)"
  "for (byte till newline || change state)" -> "process (byte)"
  "for (byte till newline || change state)" -> "update (state)"
  "update (state)" -> "for (byte in file_bytes)"
}
-->