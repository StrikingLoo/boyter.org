<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>Sloc Cloc and Code - Can a crusty Go program outperform a well written Rust Project?</title>
		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">
		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Sloc Cloc and Code</h1>
					<h3>Can a crusty Go program outperform a well written Rust Project?</h3>
				</section>
				<section>
					<table>
						<tr>
							<td>
								<img src="./img/ben.jpg" >
							</td>
							<td>
								Ben Boyter<br>
								Offically Tech Lead<br>
								Really a Code Monkey for <a href="https://www.kablamo.com.au/">Kablamo</a>.
								<pre><code style="font-size: 16px;">func Produce(c Coffee, b Beer) (Code, Cloud, []error)</code></pre>
								Can a crusty Go program outperform a well written Rust Project?<br>
							</td>
						</tr>
					</table>
				</section>

				<section>
					<img src="./img/overcorrecting.jpg" height="650px" />
				</section>

				<section>
					<h2>Code Iceberg</h2>
					<img src="./img/code-iceberg.jpg" />
					<small>Image by Â© Ralph A. Clevenger/CORBIS</small>
				</section>

				<section>
					<h2>How to spot code icebergs?</h2>
					<p>
					SLOC/CLOC counters<br>
					<a href="https://github.com/AlDanial/cloc">cloc</a> (the OG) counts blank lines, comment lines, and physical lines of source code in many programming languages<br>
					VERY full featured.<br>
					All other tools descend from it
					</p>
				</section>

				<section>
					<h2>How to spot code icebergs? Continued...</h2>
					<p>
					Cyclomatic Complexity
					<img src="./img/code-metrics.jpg" />
					</p>
				</section>

				<section>
					<h2>Are you thinking what I am!?</h2>
					<p>
					We totally need another code counter!<br><br>
					But lets see if anyone has considered this...<br>
					<a href="https://github.com/XAMPPRocky/tokei">tokei</a>, <a href="https://github.com/cgag/loc">loc</a>, <a href="https://github.com/vmchale/polyglot">polyglot</a>, <a href="https://gitlab.com/esr/loccount">loccount</a> and <a href="https://github.com/hhatto/gocloc">gocloc</a>
					<br><br>
					NONE do code complexity.
					</p>
				</section>

				<section>
					<h2>Goals!</h2>
					Learn Go.<br>
					Be as fast as possible (and TRY to beat tokei and loc).<br>
					Push CPU to limits (unlikely) OR to my limits (likely)<br>
					Be as accurate as possible<br>
					Be a library<br>
					Guess complexity<br>
				</section>


				<section>
					<h2>Design</h2>
Processes seperated by channels<br>
Channel buffers limited to CPU cores for backpressure.<br>
Tried intermediate channel buffers... no difference<br>
<img src="./img/design1.jpg" />
				</section>

				<section>
					<h2>1. File Walking</h2>
					Go's <a href="https://boyter.org/2018/03/quick-comparison-go-file-walk-implementations/">built in file walk is slow</a>! (comparatively)<br>
					Probably because its also deterministic

					

					https://github.com/boyter/scc/blob/master/examples/performance_tests/create_folders_with_files.py

					# GRAPH HERE SHOWING
<pre>
Case 0 Create a directory thats quite deep and put a 10000 files at the end
Case 1 Create a directory thats quite deep and put 100 files in each folder
Case 2 Create a directory that has a single level and put 10000 files in it
Case 3 Create a directory that has a two levels with 10000 directories in the second with a single file in each
Case 4 Create a directory that with 10 subdirectories and 1000 files in each
Case 5 Create a directory that with 20 subdirectories and 500 files in each
Case 6 Create a directory that with 5 subdirectories and 2000 files in each
Case 7 Create a directory that with 100 subdirectories and 100 files in each
</pre>


				</section>

				<section>
					<h2>File Walk Process</h2>
					What about .gitignore files?
				</section>


				<section>
					<h2>File Reading</h2>
					<p>
					Know your use case! 18554 bytes in my case<br>
					Memory maps or Scanner?<br>
					Burnt a lot of time here.<br>
<pre>$ time scc linux
DEBUG 2018-03-27T21:34:26Z: milliseconds to walk directory: 7593
--SNIP--
scc linux  11.02s user 19.92s system 669% cpu 7.623 total</pre>
					</p>

				</section>

				<section>
					<h2>File Processor</h2>
					<p>3 main ways to count code.</p>
					<ol>
						<li>Use regular expressions</li>
						<li>Use abstract syntax tree (AST)</li>
						<li>State machine</li>
					</ol>

				</section>


				<section>
					<h2>Mechanical Sympathy</h2>
					<blockquote>"You don't have to be an engineer to be be a racing driver, but you do have to have Mechanical Sympathy."</blockquote>
					<img src="./img/jackie-stewart.jpg" height="300px" />
				</section>

				<section>
					<h2>How to Go fast Multicore Edition</h2>
					<p>
					Do as little as possible.<br>
					On many cores.<br>
					Make it easy to do the next thing.<br><br>
					The key to making programs fast is to make them do practically nothing<br>
					</p>
				</section>

				


				<section>
					<h2>Fair Benchmarks</h2>
					No such thing.

					https://github.com/boyter/scc/blob/master/examples/performance_tests/create_performance_test.py

					Tried to create one as fair as possible
				</section>

				<section>
					<h2>Flame Graph</h2>
					<img src="./img/flame-graph.jpg" />
				</section>


				<section>
					<h2>Loop and check state VS change state and loop</h2>
					<table>
						<tr>
							<td><img src="./img/process1.png" /></td>
							<td><img src="./img/process2.png" /></td>
						</tr>
					</table>
				</section>


				<section>
					<h2>Byte Comparison</h2>

					Which is fastest?

<pre><code style="font-size: 16px;">equal := reflect.DeepEqual(one, two)</code></pre>
<pre><code style="font-size: 16px;">equal := bytes.Equal(one, two)</code></pre>
<pre><code style="font-size: 16px;">equal := true
for j := 0; j < len(one); j++ {
	if one[j] != two[j] {
		equal = false
		break
	}
}
</code></pre>

				</section>

			</div>
		</div>
		<script src="js/reveal.js"></script>
		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>


<!--
http://webgraphviz.com/

digraph G {
  "for (byte in file_bytes)" -> "switch (state)"
  "switch (state)" -> "process (byte)"
  "process (byte)" -> "update (state)"
  "update (state)" -> "for (byte in file_bytes)"
}

digraph G {
  "for (byte in file_bytes)" -> "switch (state)"
  "switch (state)" -> "process (byte)"
  "process (byte)" -> "for (byte till newline || change state)"
  "for (byte till newline || change state)" -> "process (byte)"
  "for (byte till newline || change state)" -> "update (state)"
  "update (state)" -> "for (byte in file_bytes)"
}
-->