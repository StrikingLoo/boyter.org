---
title: Working with Rust
author: Ben E. Boyter
type: post
date: 2017-09-09T21:59:08+00:00
url: /2017/09/working-rust/
nkweb_code_in_head:
  - default
nkweb_Use_Custom_js:
  - default
nkweb_Use_Custom_Values:
  - default
nkweb_Use_Custom:
  - 'false'
categories:
  - Rust

---
For a while I have been wanting to play with a new programming language. Professionally I work with Java, C#, Python and JavaScript and so I went looking for something complimentary to them.

My first stop was was Go. I started by implementing a vector space search in it which you can see hereÂ <https://github.com/boyter/golangvectorspace>

While I liked the syntax (I still cannot think in Go), the libraries and the performance I realized that Go is close to a hybrid of Java and Python for me. It has the [performance of Java][1] with the Python style syntax. This is fine but I really wanted to push what I already am familiar with.

I decided I would have a go at a much lower level language. This mean either C, C++, D or Rust. I had a quick tinker with D and while I liked it it felt a little like C#. Rather than go with C or C++ I decided to try Rust.

Not being familiar at all with Rust I decided rather than start with building a Vector Space in it I would run through a few of the [Project Euler problems][2].

<pre>// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.
// Answer 233168
fn euler_1() -&gt; i32 {
	let mut sum = 0;

	for i in 1..1000 {
		if i % 3 == 0 {
			sum += i;
		}
		else if i % 5 == 0 {
			sum += i;
		}
	}

	sum
}
</pre>

The above is my answer to problem 1 using Rust. Pretty simple really and I only had to look up a few things from the guide. The below answer to question two was however a little more complex. I do like the functional approach iteration. While the below works, I suspect that it could be more idiomatic if rather than looping for the answer that I could chain a filter in there somehow.

<pre>// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
// Answer 4613732
fn euler_2() -&gt; i32 {
	let mut v: Vec = Vec::new();
	v.push(1);
	v.push(2);

	let mut sum: i32 = v.iter().rev().take(2).sum();
	while sum &lt; 4000000 {
		v.push(sum);
		sum = v.iter().rev().take(2).sum();
	}

	let mut answer: i32 = 0;
	for val in v.into_iter() {
		if val % 2 == 0 {
			answer += val
		}
	}

	answer
}
</pre>

EDIT &#8211; Made it more idiomatic

<pre>// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
// Answer 4613732
fn euler_2() -&gt; i32 {
	let mut v = vec![1,2];

	let mut sum: i32 = v.iter().rev().take(2).sum();
	while sum &lt; 4000000 {
		v.push(sum);
		sum = v.iter().rev().take(2).sum();
	}

	let answer: i32 = v.into_iter().filter(|x| x % 2 == 0).sum();
	answer
}
</pre>

My plan is to eventually work my way up to solving [Problem 35][3] which was posted as one of the weekly quiz questions at work the other day. Hoping that with some free time I will be able to dip into Rust over the next few weeks. You can watch my progress if so inclined on Github <https://github.com/boyter/working-with-rust>

 [1]: http://www.boyter.org/2017/03/golang-solution-faster-equivalent-java-solution/
 [2]: https://projecteuler.net/archives
 [3]: https://projecteuler.net/problem=35